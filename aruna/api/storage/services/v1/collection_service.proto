syntax = "proto3";

package aruna.api.storage.services.v1;
option go_package = "github.com/ArunaStorage/go-api/aruna/api/storage/services/v1";
option java_multiple_files = true;
option java_package = "com.github.ArunaStorage.java_api.aruna.api.storage.services.v1";
option java_outer_classname = "CollectionService";

import "aruna/api/storage/models/v1/models.proto";
import "aruna/api/storage/models/v1/query.proto";

import "google/api/annotations.proto";

service CollectionService {

  // CreateNewCollection creates a new Collection
  rpc CreateNewCollection(CreateNewCollectionRequest)
      returns (CreateNewCollectionResponse) {
    option (google.api.http) = {
      post : "/v1/collection"
      body : "*"
    };
  }

  // GetCollection queries a specific Collection by ID
  // The result can be one_of:
  // CollectionOverview -> default
  // CollectionWithID
  // Collection (full)
  // This can be modified with the optional OutputFormat parameter
  rpc GetCollectionByID(GetCollectionByIDRequest)
      returns (GetCollectionByIDResponse) {
    option (google.api.http) = {
      get : "/v1/collection/{collection_id}"
    };
  }

  // GetCollections queries multiple collections by ID or by LabelFilter
  // This returns by default a paginated result with 20 entries.
  rpc GetCollections(GetCollectionsRequest) returns (GetCollectionsResponse) {
    option (google.api.http) = {
      get : "/v1/project/{project_id}/collections"
    };
  }

  // UpdateCollection updates the current collection
  // This will update the collection in place if it is unversioned / latest
  // A versioned (pinned) collection requires a new semantic version after the
  // update This can be used to pin a collection to a specific version similar
  // to the PinCollectionVersion request
  rpc UpdateCollection(UpdateCollectionRequest)
      returns (UpdateCollectionResponse) {
    option (google.api.http) = {
      put : "/v1/collection/{collection_id}"
      body : "*"
    };
  }

  // PinCollectionVersion this pins the current status of the version to a
  // specific version This effectively creates a copy of the collection with a
  // stable version All objects will be pinned to an explicit revision number
  // Pinned collections can not be updated in place
  rpc PinCollectionVersion(PinCollectionVersionRequest)
      returns (PinCollectionVersionResponse) {
    option (google.api.http) = {
      post : "/v1/collection/{collection_id}/pin"
      body : "*"
    };
  }

  // This request deletes the collection.
  // If with_version is true, it deletes the collection and all its versions.
  // If cascade is true, all objects that are owned by the collection will also
  // deleted. This should be avoided
  rpc DeleteCollection(DeleteCollectionRequest)
      returns (DeleteCollectionResponse) {
    option (google.api.http) = {
      delete : "/v1/collection/{collection_id}"
    };
  }
}

// Models:

message CreateNewCollectionRequest {
  string name = 1;
  string description = 2;
  string project_id = 3;
  repeated storage.models.v1.KeyValue labels = 4;
  repeated storage.models.v1.KeyValue hooks = 5;
  // Optional dataclass
  storage.models.v1.DataClass dataclass = 6;
}

message CreateNewCollectionResponse { string collection_id = 1; }

message GetCollectionByIDRequest { string collection_id = 1; }

message GetCollectionByIDResponse {
  storage.models.v1.CollectionOverview collection = 1;
}

message GetCollectionsRequest {
  // Filter by Labels (optional) OR request a specific list of Collections by id
  string project_id = 1;
  storage.models.v1.LabelOrIDQuery label_or_id_filter = 2;
  storage.models.v1.PageRequest page_request = 3;
}

message GetCollectionsResponse {
  // These are plural representations of their specific single counterparts
  storage.models.v1.CollectionOverviews collections = 1;
}

// This updates the collection
// Updating a pinned collection will require a new version to be created
message UpdateCollectionRequest {
  string collection_id = 1;
  string name = 2;
  string description = 3;
  repeated storage.models.v1.KeyValue labels = 4;
  repeated storage.models.v1.KeyValue hooks = 5;

  repeated storage.models.v1.LabelOntology label_ontology = 6;

  // Optional update Dataclass, this will not overwrite
  // the dataclass of all existing associated objects
  // New objects can only have this dataclass
  storage.models.v1.DataClass dataclass = 7;

  // If this is set, the collection will be automatically pinned to this version
  // Similar to the more explicit Pin request
  // Updating a pinned collection will make this field required
  // (optional if unpinned || required if pinned)
  storage.models.v1.Version version = 8;
}

message UpdateCollectionResponse {
  storage.models.v1.CollectionOverview collection = 1;
}

message PinCollectionVersionRequest {
  string collection_id = 1;
  storage.models.v1.Version version = 2;
}

message PinCollectionVersionResponse {
  storage.models.v1.CollectionOverview collection = 1;
}

message DeleteCollectionRequest {
  string collection_id = 1;
  bool force = 2;
}

message DeleteCollectionResponse {}