syntax = "proto3";

package aruna.api.storage.services.v1;
option go_package = "github.com/ArunaStorage/go-api/aruna/api/storage/services/v1";
option java_multiple_files = true;
option java_package = "com.github.ArunaStorage.java_api.aruna.api.storage.services.v1";
option java_outer_classname = "CollectionService";

import "aruna/api/storage/models/v1/models.proto";
import "aruna/api/storage/models/v1/query.proto";

import "google/api/annotations.proto";

// CollectionService
//
// Contains all methods that get/create or update Collection and associated resources
service CollectionService {

  // CreateNewCollection
  //
  // creates a new Collection
  rpc CreateNewCollection(CreateNewCollectionRequest)
      returns (CreateNewCollectionResponse) {
    option (google.api.http) = {
      post : "/v1/collection"
      body : "*"
    };
  }

  // GetCollectionByID
  //
  // Queries a specific Collection by ID
  // The result can be one_of:
  // CollectionOverview -> default
  // CollectionWithID
  // Collection (full)
  // This can be modified with the optional OutputFormat parameter
  rpc GetCollectionByID(GetCollectionByIDRequest)
      returns (GetCollectionByIDResponse) {
    option (google.api.http) = {
      get : "/v1/collection/{collection_id}"
    };
  }

  // GetCollections
  //
  // queries multiple collections by ID or by LabelFilter
  // This returns by default a paginated result with 20 entries.
  // Must specify a project_id as context
  rpc GetCollections(GetCollectionsRequest) returns (GetCollectionsResponse) {
    option (google.api.http) = {
      get : "/v1/collections/{project_id}"
    };
  }

  // UpdateCollection
  //
  // Updates the current collection
  // This will update the collection in place if it is unversioned / latest
  // A versioned (pinned) collection requires a new semantic version after the
  // update This can be used to pin a collection to a specific version similar
  // to the PinCollectionVersion request
  rpc UpdateCollection(UpdateCollectionRequest)
      returns (UpdateCollectionResponse) {
    option (google.api.http) = {
      put : "/v1/collection/{collection_id}"
      body : "*"
    };
  }

  // PinCollectionVersion
  //
  // This pins the current status of the version to a
  // specific version. Effectively creating a copy of the collection with a
  // stable version All objects will be pinned to an explicit revision number
  // Pinned collections can not be updated in place
  rpc PinCollectionVersion(PinCollectionVersionRequest)
      returns (PinCollectionVersionResponse) {
    option (google.api.http) = {
      post : "/v1/collection/{collection_id}/pin"
      body : "*"
    };
  }

  // DeleteCollection
  //
  // This request deletes the collection.
  // If with_version is true, it deletes the collection and all its versions.
  // If cascade is true, all objects that are owned by the collection will also
  // deleted. This should be avoided
  rpc DeleteCollection(DeleteCollectionRequest)
      returns (DeleteCollectionResponse) {
    option (google.api.http) = {
      delete : "/v1/collection/{collection_id}"
      body : "*"
    };
  }
}

// Models:

message CreateNewCollectionRequest {
  // Collection name
  string name = 1;
  // Description
  string description = 2;
  // List of associated labels
  repeated storage.models.v1.KeyValue labels = 4;
  // List of associated hooks
  repeated storage.models.v1.KeyValue hooks = 5;
  // Optional LabelOntology with required labels
  storage.models.v1.LabelOntology label_ontology = 6;
  // Optional Dataclass
  storage.models.v1.DataClass dataclass = 7;
}

message CreateNewCollectionResponse {
  // The new collection_id
  string collection_id = 1;
}

message GetCollectionByIDRequest {
  // Requested id
  string collection_id = 1;
}

message GetCollectionByIDResponse {
  // Overview of the requested collection
  storage.models.v1.CollectionOverview collection = 1;
}

message GetCollectionsRequest {
  // Project id
  string project_id = 1;
  // (optional) Filter, label or ids
  storage.models.v1.LabelOrIDQuery label_or_id_filter = 2;
  // (optional) Pagerequest
  storage.models.v1.PageRequest page_request = 3;
}

message GetCollectionsResponse {
  // List of collection overviews
  storage.models.v1.CollectionOverviews collections = 1;
}

// This updates the collection
// Updating a pinned collection will require a new version to be created
message UpdateCollectionRequest {
  // Old collection_id
  string collection_id = 2;
  // New name
  string name = 3;
  // New description
  string description = 4;
  // New list of labels
  repeated storage.models.v1.KeyValue labels = 5;
  // New list of hooks
  repeated storage.models.v1.KeyValue hooks = 6;

  // (optional) LabelOntology
  storage.models.v1.LabelOntology label_ontology = 7;

  // Optional update Dataclass, this will not overwrite
  // the dataclass of all existing associated objects
  // New objects can only have this dataclass
  storage.models.v1.DataClass dataclass = 8;

  // If this is set, the collection will be automatically pinned to this version
  // Similar to the more explicit Pin request
  // Updating a pinned collection will make this field required
  // (optional if unpinned || required if pinned)
  storage.models.v1.Version version = 9;
}

message UpdateCollectionResponse {
  // New collection overview
  storage.models.v1.CollectionOverview collection = 1;
}

message PinCollectionVersionRequest {
  // Old collection_id
  string collection_id = 1;
  // New version
  storage.models.v1.Version version = 2;
}

message PinCollectionVersionResponse {
  // New collection overview
  storage.models.v1.CollectionOverview collection = 1;
}

message DeleteCollectionRequest {
  // Collection id
  string collection_id = 1;
  // Force delete
  bool force = 3;
}

message DeleteCollectionResponse {}